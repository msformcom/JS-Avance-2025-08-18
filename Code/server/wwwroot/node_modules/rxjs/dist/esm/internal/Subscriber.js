import{isFunction}from"./util/isFunction";import{isSubscription,Subscription}from"./Subscription";import{config}from"./config";import{reportUnhandledError}from"./util/reportUnhandledError";import{noop}from"./util/noop";import{nextNotification,errorNotification,COMPLETE_NOTIFICATION}from"./NotificationFactories";import{timeoutProvider}from"./scheduler/timeoutProvider";import{captureError}from"./util/errorContext";class Subscriber extends Subscription{constructor(r){super(),this.isStopped=!1,r?(this.destination=r,isSubscription(r)&&r.add(this)):this.destination=EMPTY_OBSERVER}static create(r,t,e){return new SafeSubscriber(r,t,e)}next(r){this.isStopped?handleStoppedNotification(nextNotification(r),this):this._next(r)}error(r){this.isStopped?handleStoppedNotification(errorNotification(r),this):(this.isStopped=!0,this._error(r))}complete(){this.isStopped?handleStoppedNotification(COMPLETE_NOTIFICATION,this):(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe(),this.destination=null)}_next(r){this.destination.next(r)}_error(r){try{this.destination.error(r)}finally{this.unsubscribe()}}_complete(){try{this.destination.complete()}finally{this.unsubscribe()}}}let _bind=Function.prototype.bind;function bind(r,t){return _bind.call(r,t)}class ConsumerObserver{constructor(r){this.partialObserver=r}next(r){var t=this.partialObserver;if(t.next)try{t.next(r)}catch(r){handleUnhandledError(r)}}error(r){var t=this.partialObserver;if(t.error)try{t.error(r)}catch(r){handleUnhandledError(r)}else handleUnhandledError(r)}complete(){var r=this.partialObserver;if(r.complete)try{r.complete()}catch(r){handleUnhandledError(r)}}}class SafeSubscriber extends Subscriber{constructor(r,t,e){super();let i;i=isFunction(r)||!r?{next:null!=r?r:void 0,error:null!=t?t:void 0,complete:null!=e?e:void 0}:this&&config.useDeprecatedNextContext?((t=Object.create(r)).unsubscribe=()=>this.unsubscribe(),{next:r.next&&bind(r.next,t),error:r.error&&bind(r.error,t),complete:r.complete&&bind(r.complete,t)}):r,this.destination=new ConsumerObserver(i)}}function handleUnhandledError(r){(config.useDeprecatedSynchronousErrorHandling?captureError:reportUnhandledError)(r)}function defaultErrorHandler(r){throw r}function handleStoppedNotification(r,t){let e=config.onStoppedNotification;e&&timeoutProvider.setTimeout(()=>e(r,t))}let EMPTY_OBSERVER={closed:!0,next:noop,error:defaultErrorHandler,complete:noop};export{Subscriber,SafeSubscriber,EMPTY_OBSERVER};